"""
Script: plot_wrk_bm_tests_comparison.py

Description:
This script parses CSV files generated by the 'run_wrk_bm.py' tool to create comparative plots 
of latency percentiles and requests per second (RPS) across multiple benchmark test cases.
The script reads the CSV files, processes data grouped by unique combinations of thread/connection counts, 
and generates plots for each combination.

Key Features:
- Parses CSV files to extract latency and RPS data.
- Groups results by thread/connection combinations.
- Generates comparative plots of latency percentiles and RPS across test cases.
- Saves the output as PNG files for easy visualization.

Usage:
1. Ensure the CSV files (e.g., bm_results_<test_case>.csv) are generated by the 'run_wrk_bm.py' tool.
2. Run this script, specifying the folder containing the CSV files and an output folder for the plots.

Example:
    python plot_wrk_bm_tests_comparison.py -i ./csv_files -o ./plots
"""
import os
import argparse
import pandas as pd
import matplotlib.pyplot as plt

def parse_csv_file(file_path):
    # Read the CSV file into a pandas DataFrame
    df = pd.read_csv(file_path, header=0)
    
    # Rename columns to ensure consistent format
    df.rename(columns={
        "Latency (ms)": "latency",
        "Requests/sec": "requests_per_sec",
        "Threads": "threads",
        "Connections": "connections",
        "API": "url"
    }, inplace=True)
    
    # Extract the endpoint postfix from the URL
    df["url"] = df["url"].apply(lambda x: "/".join(x.split("/", 3)[-1:]))
    return df

def strip_prefix(url, prefixes):
    for prefix in prefixes:
        if prefix in url:
            return url.split(prefix, 1)[-1]  # Remove the prefix and keep everything after it
    return url  # Return the original URL if no prefix matches

# generates plots per connection_threads
def plot_per_connection_threads(dataframes, output_folder):
    
    # Create a combined DataFrame with all results
    combined_df = pd.concat(dataframes, keys=[df.name for df in dataframes], names=["test_case"])
    
    # Ensure column names are consistent
    if "latency" not in combined_df.columns or "requests_per_sec" not in combined_df.columns:
        raise ValueError("Required columns (latency, requests_per_sec) are missing in the input data.")

    # Transform `url` column to strip prefixes globally
    endpoint_skip = ["ufmRest/"]
    combined_df["url"] = combined_df["url"].apply(lambda url: strip_prefix(url, endpoint_skip))

    # Create unique identifiers for connection_threads
    combined_df["connection_threads"] = combined_df.apply(lambda x: f"{x['connections']}_{x['threads']}", axis=1)
    
    # Get unique connection_threads combinations
    unique_combinations = combined_df["connection_threads"].unique()

    # Generate plots for each connection_threads
    for combination in unique_combinations:

        subset = combined_df[combined_df["connection_threads"] == combination]
        endpoint_skip = ["ufmRest/"]
        endpoints = subset["url"].unique()

        fig, axes = plt.subplots(2, 1, figsize=(14, 12))

        # Subplot 1: Latency Comparison
        for test_case, group in subset.groupby("test_case"):
            group["url"] = pd.Categorical(group["url"], categories=endpoints, ordered=True)
            avg_latency = group.groupby("url", observed=False)["latency"].mean().reindex(endpoints)

            axes[0].plot(
                avg_latency.index,
                avg_latency,
                marker="o",
                label=f"{test_case} (Avg Latency)"
            )

        axes[0].set_title(f"Average Latency Comparison (Connections: {combination})", fontsize=16)
        axes[0].set_ylabel("Latency (ms)", fontsize=12)
        axes[0].set_xticks(range(len(avg_latency.index)))
        axes[0].set_xticklabels(avg_latency.index, rotation=45, ha="right")

        axes[0].legend(fontsize=10)
        axes[0].grid(True)

        # Subplot 2: Requests Per Second Comparison
        for test_case, group in subset.groupby("test_case"):
            group["url"] = pd.Categorical(group["url"], categories=endpoints, ordered=True)
            reqs_per_sec = group.groupby("url", observed=False)["requests_per_sec"].mean().reindex(endpoints)

            axes[1].plot(
                reqs_per_sec.index,
                reqs_per_sec,
                marker="o",
                label=f"{test_case} (Requests per Second)"
            )

        axes[1].set_title(f"Requests Per Second Comparison (Connections: {combination})", fontsize=16)
        axes[1].set_ylabel("Requests per Second", fontsize=12)
        axes[1].set_xlabel("Endpoints", fontsize=12)
        axes[1].set_xticks(range(len(reqs_per_sec.index)))
        axes[1].set_xticklabels(reqs_per_sec.index, rotation=45, ha="right")

        axes[1].legend(fontsize=10)
        axes[1].grid(True)

        # Save the plot
        output_file = os.path.join(output_folder, f"bm_comparison_tc_{combination}.png")
        plt.tight_layout()
        plt.savefig(output_file)
        plt.close()

        print(f"Plot (v1.0) saved for connection_threads {combination}: {output_file}")

if __name__ == "__main__":
    
    # parse arguments
    parser = argparse.ArgumentParser(description="Compare benchmark results from CSV files and generate plots.")
    parser.add_argument("-i", "--input_folder", type=str, required=True, help="Path to the folder containing CSV files.")
    parser.add_argument("-o", "--output_folder", type=str, required=True, help="Path to save the combined output PNG file.")
    args = parser.parse_args()

    # Read 'CSV files in the input folder ends with '_bm.csv'
    input_files = [f for f in os.listdir(args.input_folder) if f.endswith("_bm.csv")]

    if not input_files:
        print("No matching files found in the input folder.")
        exit(1)

    dataframes = []
    for file_name in input_files:
        test_case = os.path.splitext(file_name)[0].replace("_bm", "")
        file_path = os.path.join(args.input_folder, file_name)
        df = parse_csv_file(file_path)
        df.name = test_case  # Assign the test case name to the DataFrame
        dataframes.append(df)

    os.makedirs(args.output_folder, exist_ok=True)

    # Generate plots per connection_threads
    plot_per_connection_threads(dataframes, args.output_folder)    
